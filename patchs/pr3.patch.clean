diff -ruN -x __pycache__ -x '*.pyc' ./app/services/courier_match.py ./app/services/courier_match.py
--- ./app/services/courier_match.py	2026-02-13 14:27:22.000000000 +0000
+++ ./app/services/courier_match.py	2026-02-13 16:55:43.756036454 +0000
@@ -1,8 +1,15 @@
 import re
 import unicodedata
+from typing import Optional, Tuple
+
+from sqlalchemy.orm import Session
+
+from app.models import Courier, CourierAlias
+
 
 INVALID_PLACEHOLDERS = {"0", "-", "â€”", "--", "---", "N/A"}
 
+
 def norm_text(s: str) -> str:
     s = (s or "").strip()
     s = re.sub(r"\s+", " ", s)
@@ -11,10 +18,14 @@
     s2 = "".join(ch for ch in s2 if not unicodedata.combining(ch))
     return s2
 
+
 def compute_fee_type(value_raw: float) -> int:
+    """Business rule: fee_type=10 only when raw==10.00, otherwise 6."""
     return 10 if round(float(value_raw), 2) == 10.00 else 6
 
+
 def saipos_pending_reason(courier_raw: str | None) -> str | None:
+    """Reasons used when Saipos courier field is empty/placeholder/system text."""
     n = norm_text(courier_raw or "")
     if not n:
         return "VAZIO"
@@ -25,3 +36,41 @@
     if n == "ENTREGADOR NAO INFORMADO":
         return "SAIPOS_ENTREGADOR_NAO_INFORMADO"
     return None
+
+
+def match_courier_id(db: Session, courier_name_raw: str | None) -> Tuple[Optional[str], Optional[str]]:
+    """Try to resolve courier_id from courier_name_raw.
+
+    Returns:
+      (courier_id, pending_reason_if_not_matched)
+
+    pending_reason values used here:
+      - ALIAS_AMBIGUO
+      - NOME_NAO_CADASTRADO
+      - VAZIO
+    """
+    n = norm_text(courier_name_raw or "")
+    if not n:
+        return None, "VAZIO"
+
+    # 1) Strict alias lookup
+    alias_rows = (
+        db.query(CourierAlias.courier_id)
+        .filter(CourierAlias.alias_norm == n)
+        .distinct()
+        .all()
+    )
+    if len(alias_rows) == 1:
+        return str(alias_rows[0][0]), None
+    if len(alias_rows) > 1:
+        return None, "ALIAS_AMBIGUO"
+
+    # 2) Fallback: normalized compare against couriers.nome_resumido
+    candidates = db.query(Courier.id, Courier.nome_resumido).all()
+    hits = [str(cid) for (cid, nome) in candidates if norm_text(nome or "") == n]
+    if len(hits) == 1:
+        return hits[0], None
+    if len(hits) > 1:
+        return None, "ALIAS_AMBIGUO"
+
+    return None, "NOME_NAO_CADASTRADO"
diff -ruN -x __pycache__ -x '*.pyc' ./app/services/import_saipos.py ./app/services/import_saipos.py
--- ./app/services/import_saipos.py	2026-02-13 14:27:22.000000000 +0000
+++ ./app/services/import_saipos.py	2026-02-13 16:56:35.993807284 +0000
@@ -1,13 +1,14 @@
 import io
 import datetime as dt
 from typing import Tuple
+
 from openpyxl import load_workbook
 from sqlalchemy.orm import Session
 from sqlalchemy.exc import IntegrityError
 
 from app.models import Import, Ride
 from app.services.week_service import get_or_create_week_for_date
-from app.services.courier_match import compute_fee_type, saipos_pending_reason, norm_text
+from app.services.courier_match import compute_fee_type, saipos_pending_reason, norm_text, match_courier_id

@@ -17,14 +18,43 @@
             return i
     raise ValueError(f"Missing column: {name}")

-def import_saipos(db: Session, file_bytes: bytes, filename: str, file_hash: str) -> Tuple[str,int,int,int]:
+
+def _commit_rides_best_effort(db: Session, rides: list[Ride]) -> int:
+    """Commit a chunk of rides; if any constraint fails, fallback to per-row inserts.
+
+    Returns how many were inserted.
+    """
+    if not rides:
+        return 0
+    try:
+        db.add_all(rides)
+        db.commit()
+        return len(rides)
+    except IntegrityError:
+        db.rollback()
+        # Clear state of objects from the failed bulk attempt.
+        db.expunge_all()
+        inserted = 0
+        for r in rides:
+            try:
+                db.add(r)
+                db.commit()
+                inserted += 1
+            except IntegrityError:
+                db.rollback()
+                # duplicate/constraint violation -> ignore
+                continue
+        return inserted
+
+
+def import_saipos(db: Session, file_bytes: bytes, filename: str, file_hash: str) -> Tuple[str, int, int, int]:
     imp = Import(source="SAIPOS", filename=filename, file_hash=file_hash, status="DONE", meta={})
     db.add(imp)
     try:
         db.commit()
     except IntegrityError:
         db.rollback()
-        existing = db.query(Import).filter(Import.source=="SAIPOS", Import.file_hash==file_hash).first()
+        existing = db.query(Import).filter(Import.source == "SAIPOS", Import.file_hash == file_hash).first()
         return str(existing.id), 0, 0, 0
     db.refresh(imp)
